1.为项目开启迁移功能
	打开Nuget包管理控制台窗口，默认项目选择刚才创建的项目，然后在窗口中输入Enable-Migrations，最后按下Enter键即可。

2.创建数据库
	现在我们准备创建数据库了，如果在本地工作，只是创建或者更新本地数据库，那么我们在包管理器控制台中执行Update-Database命令，
还有，可以使用Get-Help命令查看可以使用的参数（后面不再啰嗦这个命令）。
下面，我们对-script参数感兴趣，该参数很有用，因为它可以生成迁移的SQL脚本，我们可以将该脚本交给DBA或者我们自己运行。
当运行Update-Database命令时，它会比较实体类、上下文创建的数据库和物理数据库的结构

3.显式迁移
	简单的情景推荐使用自动迁移，当迁移变得复杂时，自动迁移就不那么好使了；
	一般来说，显式迁移比自动迁移更加灵活，虽然需要写更多的代码，但是对于迁移有了更多控制权，比如迁移名称和回滚过程等等。
	如果我们混用了自动迁移和显式迁移，就会把自己搞糊涂。


4.显示迁移步骤：
[1]开始显式迁移之前，先要删除刚才SSMS中创建的数据库，然后使用迁移配置类中AutomaticMigrationsEnabled = false;关闭自动迁移。
	 要创建初始化数据库迁移，需要使用新的命令Add-Migration。

[2]使用更新数据库的命令：Update-Database 
   又或者使用生成数据库更新脚本的命令:Update-Database -Script ，生成脚本后手动更新或者给把脚本给DBA，让DBA更新

[3]撤回到指定的数据库迁移：Update-Database -TargetMigration [迁移名称]
   例如：Update-Database -TargetMigration 202104100941392_Donator_Name_Add_Index

5.DbMigration类
		DbMigration基类支持许多数据库工件的维护（不仅仅是列和表），我们可以执行下面的东西：
			a.创建、删除和更改存储过程
			b.添加和删除外键
			c.移动数据库模式之间的工件，例如表和存储过程
			d.重命名对象，如表、存储过程和列
			e.维护主键约束
			f.创建、重命名和删除索引
			g.最后，当遇到所说的这些方法不起作用时，可以使用Sql或者SqlFile方法。前者方法需要传入sql字符串，后者需要一个sql文件名作为参数。
			h.s所有迁移默认都以事务的一部分运行，确保所有的迁移操作要么成功，要么什么都不做

6.给已存在的数据库添加迁移
	有时，我们想为一个已存在的数据库添加EF迁移，为的是将处理模式变化从一种方式移动到迁移API。
	当然，因为数据库已存在于生产环境，所以我们需要让迁移知道迁移起始的已知状态。
	使用Add-Migration -IgnoreChanges指令处理这个是相当简单的，当执行该命令时，
	EF会创建一个空的迁移，它会假设上下文和实体定义的模型和数据库是兼容的。
	一旦通过运行这个迁移更新了数据库，数据库模式不会发生变化，
	但是会在_MigrationHistory表中添加一条新的数据来对应初次迁移。
	这个完成之后，我们就可以安全地切换到EF的迁移API来维护数据库模式变化了。

7.EF中的模型约定API可以创建两种类型约定：存储模型和概念模型约定。
这些约定允许我们在模型中的许多地方全局地应用更改，而不是一个个实体或者一个个属性地修改。
每种.Net类型也可以写多个约定，因为EF允许我们控制应用的约定的顺序

8.EF的其他功能
	EF现在已经实现了服务定位模式，因此开启了依赖注入。DI用于支持配置方法。
	比如，可以使用我们自定义方式来创建依赖解析器Resolver，然后创建通用的EF对象，例如IDbConnectionFactory。
	请通过阅读EF的文档找出可以注入到正在运行的应用中的类或接口，强制EF使用它们而不是使用默认的实现。
	也可以将一个自定义的logger注入EF，这样就可以记录EF执行的所有actions到自定义的日志源。
	要创建自定义日志，开发者可以设置Database对象的Log属性。
	Log属性需要赋予一个带有一个字符串参数的方法，如context.Database.Log = System.Console.Write;
	，这样日志就会在控制台中输出。如果你不喜欢这种记录日志的方式，也可以创建自定义的方式。

9.一个数据库，多个上下文
	我们不必总是将映射到表的所有实体集合放到一个上下文里。使用多个DbContext类有很多优点。
	这种方式可能会减少启动时间，因为这个时间一般是和上下文第一次访问的集合的数量成比例的，
	也会减少每个上下文对开发者暴露的数据面。还有，它会帮助开发者将数据组织到数据模块中。
	当然，如果我们使用迁移，我们仍然需要一个包含每个集合或表的上下文，因为我们会使用这个上下文用于支持迁移。
	这是我们需要实际配置的唯一上下文。当我们使用多个上下文并在一个事务中将数据保存到多个上下文时，
	需要做一些额外的事情。每个SaveChanges调用都是事务的，但我们需要为所有的SaveChanges调用创建一个首要的事务。
	我们也许会发现，对于涉及多个模块的保存操作，将所有的集合放到单个大型的DbContext中是更简单的。